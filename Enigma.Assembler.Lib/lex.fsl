{
module DCPU16.Assembler.Lexer
open System
open Microsoft.FSharp.Text.Lexing
open DCPU16.Assembler.Parser

let lexeme (lexbuf : LexBuffer<char>) = new System.String(lexbuf.Lexeme)

let idents =
  [
    // opcodes
    "SET", SET;
    "ADD", ADD;
    "SUB", SUB;
    "MUL", MUL;
    "DIV", DIV;
    
    // registers
    "A", REG_A;
    "B", REG_B;
    "C", REG_C;
    "X", REG_X;
    "Y", REG_Y;
    "Z", REG_Z;
  ] |> Map.ofList

let nextLine (lexbuf : LexBuffer<_>) =
  lexbuf.EndPos <- lexbuf.EndPos.NextLine

}

let whitespace = [' ' '\t']
let newline = "\n\r" | "\n" | "\r"

let char = ['a'-'z' 'A'-'Z']
let comment = ';'.*
let label   = [^';'  ':'](char)*
let ident   = [^';' ^':'](char)*
let digit   = ['0'-'9']
let int     = '-'?digit+

rule tokenize = parse
  | whitespace    { tokenize lexbuf }
  | newline       { nextLine lexbuf; tokenize lexbuf; }
  | comment       { nextLine lexbuf; tokenize lexbuf; }
  | int           { INT(Int32.Parse (lexeme lexbuf)) }
  | ident         { let input = lexeme lexbuf
                    match idents.TryFind (input.ToUpper ()) with
                    | Some token -> token
                    | None -> failwith <| sprintf "Invalid identifier `%s'" input }
  | ','           { COMMA }
  | eof           { EOF }